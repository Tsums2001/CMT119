<DOCTYPE! html>
<html>
<head>
  <title>Computational Thinking</title>
    <link rel="icon" type="image/x-icon" href="/Images/favicon.ico">
  <link rel="stylesheet" href="css.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
  <h1 class="main_title"><strong>Computational Thinking, Cardiff University (CMT119)</strong></h1>
  <section class="main_section">
    <nav>
      <h2 class="sub_title"><strong>Home</strong></h2>
      <div id="menu">
        <ul>
          <li><a href="Home.html" class="button">Home</a></li>
          <li><a href="Biography.html" class="button">Biography</a></li>
          <li><a href="Reflection.html" class="button">Reflection</a></li>
        </ul>
      </div>
      <div>
        <img class="images" src="Images/Computers.jpg" alt="image of computers">
      </div>
    </nav>
    <article>
      <p>Computional thinking is a method of developing solutions to complex problems
         and understanding them in a way that both human and/or computer can understand.
         These methods are developed into models and are mathematical abstractions, being
         collections of problem-solving methods, such as analysing, decomposing and solving.
         Or as understood by academic scholars <q><i>we define CT as the conceptual foundation required
         to solve problems effectively and efficiently (i.e., algorithmically, with or without the
         assistance of computers) with solutions that are reusable in different contexts.</i></q>
         (Asbell-Clarke, J. et al, 2017).</p>
      <p>This can also be expressed as four key techniques of computational thinking:
         decomposition (break down a big problem into a small manageable parts), abstraction
         (ignore irrelevant details), pattern recognition (recognise and reuse recurrent patterns),
         and finally algorithms (a step-by-step solution to solve a problem). These principles can
         be applied to almost any query that has an issue that we want to solve implying usage to
         everyday life.</p>
      <p>We can do this by mere thoughts, however for a computer to do these instructions there must
         be given for the computer to understand and execute what we want to do. In the highest form
         of abstract we can summarise this to mean that a computer (in most cases program) takes in
         data via an input, performs our computational tasks, then returns with an output.
         Furthermore, within these programs are the main building blocks that allow the expression
         of computational thought for computers, that being variables, literals and operators,
         comments, functions, conditions, and loops.</p>
      <p>For a closer real-world example of how this computational model could be expressed we
         would imagine a JS Machine that consists of arbitrary memory cells and a processor that
         performs instructions, the programming language that we could use for the computer is
         Java Script. This language would be processed more primitively (compiled/interpreted)
         for the computer to understand what to do. The fundamental building block of all relations
         with computers and procedural programming languages are variables as they allow referring
         to memory cells, noted that all variables must be declared before a variable is used.
         Memory models have a finite amount of storage (bits) and use memory addresses rather than
         memory cells (expressed by a hexadecimal number system).</p>
      <p>This allows for overflows in memory to occur, which can cause errors in the handling of
         new data that can completely change the output of what we would expect to see.
         This is due to data types having fixed number of bits that can cause never ending program
         with no solution, or for programs to loop back in of itself. Normally most programs
         should have techniques to avoid this such as <q><i>Safety run-time checks</q></i> and
         <q><i>Reusing dead space</q></i>, the first states that the program if the memory is
         overloaded with simply shutdown and display a run time error due to inefficient memory
         like an industrial machine, the second is that it will automatically fill the data into
         memory that is no longer being used in any protocols that are dead, or goes into free
         holes in the heap segment (Barua, R. et al, 2006).</p>
      <h3>References:</h3>
      <li>Shute, V.J., Sun, C. and Asbell-Clarke, J., 2017. Demystifying computational thinking. Educational research review, 22, pp.142-158.</li>
      <li>Biswas, S., Carley, T., Simpson, M., Middha, B. and Barua, R., 2006. Memory overflow protection for embedded systems using run-time checks, reuse, and compression. ACM Transactions on Embedded Computing Systems (TECS), 5(4), pp.719-752.</li>
    </article>
  </section>
  <section>
    <footer>
      <p>email: summerst3@cardiff.ac.uk, name: Tyler Summers, student id: 2010675</p>
    </footer>
  </section>
</body>
</html>
